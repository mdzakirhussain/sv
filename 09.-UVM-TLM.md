# UVM TLM(Transaction Level Modeling)

Transaction level modeling (TLM) is a standard mechanism to communicate data between components. It handles the entire process of communication.
Here data is represented as transactions that will flow in and out of different components via special ports called TLM interfaces.    


![gif 2](https://user-images.githubusercontent.com/110412468/200250968-e250d81b-238e-4bda-8f47-9bae54e7f6db.gif)

```
Gif.1 - Data Transfer between components using ports
```

### TLM provides    
1. unidirectional, bidirectional, or broadcasting manner communication between components.   
2. One component to multiple components connection.    
3. The mechanism uses task and function methods to establish a connection.    
4. FIFO can hold transactions and get them based on the requirement.    
5. Connection to different programming languages.   

### Advantages of TLM    
1. Reusable in different verification environments.   
2. Ports can be replaced easily by changing port declarations and methods.   



|S.no.|Topic|
|:-----|:----|
|1.|[TLM put operation](https://github.com/muneeb-mbytes/UVM_Course/wiki/09.-UVM-TLM#tlm-put-operation)|
|2.|[TLM put->Export->Imp](https://github.com/muneeb-mbytes/UVM_Course/wiki/09.-UVM-TLM#uvm-tlm-port-to-export-to-imp)|
|3.|[TLM get operation](https://github.com/muneeb-mbytes/UVM_Course/wiki/09.-UVM-TLM#tlm-get-port)|
|4.|[TLM FIFO](https://github.com/muneeb-mbytes/UVM_Course/wiki/09.-UVM-TLM#tlm-fifo)|
|5.|[TLM Example](https://github.com/muneeb-mbytes/UVM_Course/wiki/09.-UVM-TLM#uvm-tlm-example)|
|6.|[TLM Analysis port](https://github.com/muneeb-mbytes/UVM_Course/wiki/09.-UVM-TLM#tlm-analysis-port)|
|7.|[TLM Sockets](https://github.com/muneeb-mbytes/UVM_Course/wiki/09.-UVM-TLM#tlm-sockets)|
|8.|[TLM decl_macros](https://github.com/muneeb-mbytes/UVM_Course/wiki/09.-UVM-TLM#tlm-decl-macros)|

   
    

## TLM put operation  
Using TLM `put` port any component can send data to another component. Implementation of the `put` port must be defined in receiving component.    

![put drawio](https://user-images.githubusercontent.com/113421183/200116693-5eca5ecc-a52b-497f-a558-03a8016d3535.png)   

```
Fig.1 - components connection and data flow
```
Port will always be the initiator and export will always be the responder      
There are two scenarios:  
1. Control flow: This flow initiates transactions.    
2. Data flow:  This flow says the data flow between components.


Component A initiates the transaction and sends a request to Component B if the data flow is from Component A to Component B then such kind of scenario could be implemented with put operation.    

The port can be either blocking or nonblocking, it will decide whether the `put` method will block the execution in the initiator until the responder accepts the object.   

### TLM Blocking put port    

In the Blocking put port, the `put` method will block the execution in the sender until the receiver accepts the object.     
There are 3 classes in put operation:  
1. uvm_blocking_put_port  
      This class will be used inside the class which initiates transactions.   
    `uvm_blocking_put_port #(parameter) port_inst`    
  
2. uvm_blocking_put_export   
      This class will be used inside the class which will respond to the transaction.    
     `uvm_blocking_put_export #(parameter) export_inst`     

3. uvm_blocking_put_imp    
      This class handles the entire process of communication. It consists of the methods that could be used to send the data between port and export.   
      `uvm_blocking_put_imp #(parameter , current_class_name) imp_inst`     

> **Note**   
Export cannot be the endpoint of the communication, the last port must be implementation.   

**Example**   

```
       class component1 extends uvm_component;
        `uvm_component_utils(component1)
  
         int data = 20;
  
         uvm_blocking_put_port #(int) port;
 
         function new(input string path = "Component A", uvm_component parent = null);
          super.new(path, parent);
         endfunction
 
         virtual function void build_phase(uvm_phase phase);
          super.build_phase(phase);
          port  = new("port", this);
         endfunction
 
         task main_phase(uvm_phase phase);
           phase.raise_objection(this);
          port.put(data);
          `uvm_info("PROD" , $sformatf("Data Sent : %0d", data), UVM_NONE);
          phase.drop_objection(this);
         endtask
 
       endclass
       
       class component2 extends uvm_component;
        `uvm_component_utils(component2)

         uvm_blocking_put_export #(int) expo;
         uvm_blocking_put_imp #(int, component2) imp;
    
         function new(input string path = "Component B", uvm_component parent = null);
          super.new(path, parent);
         endfunction
 
         virtual function void  build_phase(uvm_phase phase);
          super.build_phase(phase);
          expo  = new("expo", this);
          imp = new("imp", this);
        endfunction
 
        task put(int datar);
         `uvm_info("CONS" , $sformatf("Data Rcvd : %0d", datar), UVM_NONE);
        endtask
 
       endclass

       class env extends uvm_env;
        `uvm_component_utils(env)

        component1 c1;;
        component2 c2;

        function new(input string path = "env", uvm_component parent = null);
         super.new(path, parent);
        endfunction
 
        virtual function void build_phase(uvm_phase phase);
         super.build_phase(phase);
         c1 = component1::type_id::create("c1",this);
         c2 = component2::type_id::create("c2", this);
        endfunction
 
        virtual function void connect_phase(uvm_phase phase);
         super.connect_phase(phase);
         c1.port.connect(c2.expo);
         c2.expo.connect(c2.imp);
        endfunction
 
       endclass

       module tb;

        initial begin
         run_test("test");
        end

       endmodule

```
```
Example.1 - Blocking put code 
```

**Github Code link**: https://github.com/muneeb-mbytes/UVM_Course/blob/b7_Team_SiliconCrew/TLM/TLM_put_method/blocking_put/blocking_put.sv  

**Github log file link**: https://github.com/muneeb-mbytes/UVM_Course/blob/b7_Team_SiliconCrew/TLM/TLM_put_method/blocking_put/blocking_put_log.log    

Here data has some value that is of int type so that will be sent from one component to another component. `uvm_blocking_put_port` must be declared inside the class which is sending data, here it is Component1. `uvm_blocking_put_export` and `uvm_blocking_put_imp` must be declared inside the class which is receiving the data in the example it is Component2. The port has to be instantiated with the `new()` method inside the build_phase of the same component.    
In the Component1 class, a handle for the `put_port` class must be created, and using that handle data will be sent by calling the `put()` method. In the Component2 class, a handle for the `put_export` and `put_imp` will be created. Since port declaration blocking is in nature, `put` implementation is a task that has to be defined in the receiver class. In the higher level connect all the ports inside connect_phase.
 
**Output snap**   
 
The output for blocking put operation is shown below.    
![blocking_put](https://user-images.githubusercontent.com/113421183/200134576-d65cc2f0-6ba2-4640-9a31-89299337883c.png)  
```
Fig.2 - output for put operation using port and export & Imp 
```  

Here the data which is sent is 20 from Component1 and Component2 receives the data. Here both export and implementation port has been used. We can do without using export but an implementation port must be used.


* The below snap shows the output for blocking put without imp port.  
  
![without_imp](https://user-images.githubusercontent.com/113421183/200134891-b89667f7-9f40-49ba-b9ee-d6268c11264a.png)    
```
Fig.3 - Error for Without including Imp  
```
     
If the implementation is not declared there will be an error.    

### TLM Nonblocking put port    
Similar to blocking in nonblocking `uvm_nonblocking_put_port` must be declared and created inside the sender class. `uvm_nonblocking_put_imp`  must be declared and created inside receiving class. 
Instead of `put` here we use `try_put` to know whether the put was successful and `can_put` to see if the receiver is ready to accept the transfer.   

**Example**   
  
```
       class component1 extends uvm_component;
        `uvm_component_utils(component1)
  
        int data = 12;
  
        uvm_nonblocking_put_port #(int) port;
 
        function new(input string path = "component1", uvm_component parent = null);
         super.new(path, parent);
        endfunction
 
        virtual function void build_phase(uvm_phase phase);
         super.build_phase(phase);
         port  = new("port", this);
        endfunction
 
        task main_phase(uvm_phase phase);
         phase.raise_objection(this);
         repeat(2)begin
         int trans;
         trans = port.try_put(data);
         `uvm_info("PROD" , $sformatf("Data Sent : %0d", data), UVM_NONE);
         if(trans)
           `uvm_info("non blocking",$sformatf("transaction completed"), UVM_MEDIUM)
         else
           `uvm_info("non blocking",$sformatf("transaction failed"), UVM_MEDIUM)
         end
         phase.drop_objection(this);
 
        endtask
 
       endclass

       class component2 extends uvm_component;
        `uvm_component_utils(component2)
 
        uvm_nonblocking_put_imp #(int, component2) imp;
        function new(input string path = "component2", uvm_component parent = null);
         super.new(path, parent);
        endfunction
 
        virtual function void build_phase(uvm_phase phase);
         super.build_phase(phase);
         imp = new("imp", this);
        endfunction
 
        virtual function try_put(int datar);
         `uvm_info("CONS" , $sformatf("Data Rcvd : %0d", datar), UVM_NONE);
          return 1;
        endfunction
      
        virtual function bit can_put();
        endfunction
 
       endclass
 
       module tb;
         initial begin
         run_test("test");
         end
       endmodule     
```
```
Example.2 - Non-Blocking put port code
```  

**GitHub code link:** https://github.com/muneeb-mbytes/UVM_Course/blob/b7_Team_SiliconCrew/TLM/TLM_put_method/non_blocking_put/non_blocking_put.sv  

**GitHub log file link:**https://github.com/muneeb-mbytes/UVM_Course/blob/b7_Team_SiliconCrew/TLM/TLM_put_method/non_blocking_put/non_blocking_put_log.log     

* Declared and created TLM port in Component1.  
* Declared and created TLM IMP port in Component2.    
* Connect TLM port and IMP port in env class.    
* Call the interface method in component1 to send the transaction(port.try_put(data))   
* Implement an interface method in componennt2 to receive the transaction. `try_put` and `can_put` methods must be implemented since it is a nonblocking port method that has to be a function not a task.   





**Output snap**   
The output for the nonblocking put operation is shown below. 

![nonblocking_put](https://user-images.githubusercontent.com/113421183/200186931-1ee06281-3737-4ec2-bbfa-18a3c193aa83.png)      

``` 
Fig.4 - Non-blocking put output
```
Here both `try_put` and `can_put` have been used, if `can_put` is not used means a run time error will arise. `can_put` just say whether the receiver is ready to accept the transaction or not. If `try_put` returns 1 and `can_put` returns 0 then transaction will be failed.   






***

## UVM TLM Port to Export to Imp  


TLM ports and Export are mainly used to send the transaction objects cross different levels of the test bench hierarchy.  

**Port:** shall be used to initiate and forward packets to the Top layer of the Hierarchy.  

**Export:** Shall be used to accept and forward packets from the Top layer to the destination.  

**Implementation Ports:** shall be used to define the put method at the target.  


**Check sheet for TLM port to Export to Imp**

|Sl.No.| Name|  
|:------|:-------|
|1.|[Port to Imp](https://github.com/muneeb-mbytes/UVM_Course/wiki/09.-UVM-TLM#1port-to-imp)|
|2.|[Port to Port to Imp](https://github.com/muneeb-mbytes/UVM_Course/wiki/09.-UVM-TLM#2port-to-port-to-imp)|
|3.|[Port to Export to Imp](https://github.com/muneeb-mbytes/UVM_Course/wiki/09.-UVM-TLM#3port-to-export-to-imp)| 
|4.|[Port to port to Export to Imp](https://github.com/muneeb-mbytes/UVM_Course/wiki/09.-UVM-TLM#4port-to-port-to-export-to-imp)|


## 1.Port to Imp  

In this example, we were doing **Port** to **Imp**. The Producer forwards the packet to the Consumer. and the Producer is using the **port** to send packets to Consumer. and Consumer receiving data using **Implementation**.  




![Port_Imp](https://user-images.githubusercontent.com/106074838/200192309-dc15abbe-1607-4d1c-ba26-08aab5e1ac29.png)

            Fig.5- Port to Imp  



* **Code**  

**Producer Code**  

         class producer extends uvm_component;
         `uvm_component_utils(producer)

         int data = 12;

        uvm_blocking_put_port #(int) send;

         function new(input string path = "producer", uvm_component parent = null);
         super.new(path, parent);
          endfunction

        virtual function void build_phase(uvm_phase phase);
         super.build_phase(phase);
         send  = new("send", this);
         endfunction


        task main_phase(uvm_phase phase);
         phase.raise_objection(this);
        `uvm_info("PROD", $sformatf("Data Sent : %0d", data), UVM_NONE); 
         send.put(data);
         phase.drop_objection(this);
        endtask
          endclass  


**Consumer Code**  
```
        Class consumer extends uvm_component;
         `uvm_component_utils(consumer)

           uvm_blocking_put_imp#(int, consumer) imp;

           function new(input string path = "consumer", uvm_component parent = null);
            super.new(path, parent);
            endfunction

           virtual function void build_phase(uvm_phase phase);
           super.build_phase(phase);
          imp  = new("imp", this);
           endfunction


        function void put(int datar);
         `uvm_info("Cons", $sformatf("Data Rcvd : %0d", datar), UVM_NONE);
      endfunction

        endclass

```
```
Example.3 - Tlm Port to Imp 
```

In the above code example, we were using Producer as a source, and it sent a data value is 12 using this syntax `uvm_blocking_put_port #(int) port_handle_name;`. and Then Consumer receives the data value is 12 using this syntax `uvm_blocking_put_imp#(int, path) port_handle_name;`  
    



* **Output:**  


![Port_Imp_ss](https://user-images.githubusercontent.com/106074838/200192443-bf81158c-30d3-489f-a5d4-e4afeff06b0d.png)


           Fig.6- output for Port to Imp   


**GitHub lab code link:** https://github.com/muneeb-mbytes/UVM_Course/blob/b7_Team_SiliconCrew/TLM/Port_Export_Imp/port_imp/port_imp.sv 


**GitHub log code link:** https://github.com/muneeb-mbytes/UVM_Course/blob/b7_Team_SiliconCrew/TLM/Port_Export_Imp/port_imp/port_imp.sv 



## 2.Port to Port to Imp  

In this example, we were doing Port to port to Imp. The producer forwards the packet from Subproducer to the Consumer.   
here Subproducer is the Source and the destination is Consumer. The producer and Subproducer both are using the port to send the information to the Consumer and the Consumer receives data using Implementation.  
   

![Port_Port_Imp](https://user-images.githubusercontent.com/106074838/200187508-ca5c0df5-6a8d-4aad-94f7-b8fdb455897e.png)

               Fig.7- Port to Port to Imp  

* **Code:**  

**Subproducer Code**   

      include "uvm_macros.svh"
      import uvm_pkg::*;

      class subproducer extends uvm_component;
      `uvm_component_utils(subproducer)

       int data = 05;

        uvm_blocking_put_port #(int) support;

         function new(input string path = "subproducer", uvm_component parent = null);
          super.new(path, parent);
         endfunction

         virtual function void build_phase(uvm_phase phase);
         super.build_phase(phase);
         subport  = new("subport", this);
         endfunction

          task main_phase(uvm_phase phase);
          phase.raise_objection(this);
          `uvm_info("SUBPROD", $sformatf("Data Sent : %0d", data), UVM_NONE); 
           subport.put(data);
           phase.drop_objection(this);
          endtask
          endclass 

 **Producer Code**   

 
          class producer extends uvm_component;
           `uvm_component_utils(producer)
           subproducer s;

          uvm_blocking_put_port #(int) port;
          function new(input string path = "producer", uvm_component parent = null);
             super.new(path, parent);
         endfunction

         virtual function void build_phase(uvm_phase phase);
            super.build_phase(phase);
            port  = new("port", this);
            s = subproducer::type_id::create("s", this);
          endfunction
                                   
         virtual function void connect_phase(uvm_phase phase);
           super.connect_phase(phase);
        s.subport.connect(port);
       endfunction
      endclass

**consumer Code**  


       class consumer extends uvm_component;
        `uvm_component_utils(consumer)
         uvm_blocking_put_imp#(int, consumer) imp;
                
         function new(input string path = "consumer", uvm_component parent = null);
           super.new(path, parent);                          
         endfunction 
  
        virtual function void build_phase(uvm_phase phase);  
        super.build_phase(phase);
        imp   = new("imp", this); 
       endfunction

      function void put(int datar);
       `uvm_info("Cons", $sformatf("Data Rcvd : %0d", datar), UVM_NONE);
       endfunction
        endclass

**Environment Code**   


        class env extends uvm_env;
         `uvm_component_utils(env)
         producer p;   
         consumer c;
                                        
        function new(input string path = "env", uvm_component parent = null);
          super.new(path, parent);
         endfunction
                                        
         virtual function void build_phase(uvm_phase phase);
           super.build_phase(phase);
            p = producer::type_id::create("p",this);
            c = consumer::type_id::create("c", this);
           endfunction
                                        
           virtual function void connect_phase(uvm_phase phase);
           super.connect_phase(phase);  
            p.port.connect(c.imp);
           endfunction

          endclass
 
**Test Code**  

```                                                                                                                                                                             
       class test extends uvm_test;
         `uvm_component_utils(test)
          env e;
                                        
        function new(input string path = "test", uvm_component parent = null);
         super.new(path, parent);
         endfunction
  
       virtual function void build_phase(uvm_phase phase);
        super.build_phase(phase);      
       e = env::type_id::create("e",this);
       endfunction
                                        
       virtual function void end_of_elaboration_phase(uvm_phase phase);
        super.end_of_elaboration_phase(phase);
        uvm_top.print_topology();
       endfunction
      endclass
```
```
Example.4 - Tlm Port to port to Imp 
```                                                                                                                                                         



In the above code example, we were using Subproducer as a source, and it sent a data value is 5 using this syntax `uvm_blocking_put_port #(int) Port_handle_name`. Then Producer is transfer the data to Consumer. and finally, Consumer receives the data following Syntax `uvm_blocking_put_imp#(int, path) Port_handle_name`. then Consumer is receiving the data value is 5.    
    


* **Output:**  

![Port_port_Imp_ss drawio](https://user-images.githubusercontent.com/106074838/200190390-d3706478-8d9b-459b-b9f0-cc8b2ec18702.png)

        Fig.8- output for Port to Port to Imp  


**GitHub lab code link:** https://github.com/muneeb-mbytes/UVM_Course/blob/b7_Team_SiliconCrew/TLM/Port_Export_Imp/port_port_imp/port_port_imp.sv  

**GitHub log code link:** https://github.com/muneeb-mbytes/UVM_Course/blob/b7_Team_SiliconCrew/TLM/Port_Export_Imp/port_port_imp/port_port_imp.log  


## 3.Port to Export to Imp  

In this example, we were doing the Port to Export to Imp. The producer is the source and the sub-consumer is the destination. the producer sends a packet of the data using **port** and Since Consumer contains sub-consumer. then Consumer uses **Export**, and Sub-Consumer is using **Imp**, Now Sub-consumer acts like a receiver to receive the Packet of data.            


![Port_Export_Imp](https://user-images.githubusercontent.com/106074838/200192811-c0146a65-c04f-4fc3-b0bb-80fe78f42b68.png)  

         Fig.9- Port to Export to Imp  
 
* **Code**  

**Producer Code** 
  
``` 
Class producer extends uvm_component;
  `uvm_component_utils(producer)

  int data = 9;
  uvm_blocking_put_port #(int) port;

  function new(input string path = "producer", uvm_component parent = null);
    super.new(path, parent);
  endfunction

  virtual function void build_phase(uvm_phase phase);
  super.build_phase(phase);
  port  = new("port", this);
endfunction


task main_phase(uvm_phase phase);
  phase.raise_objection(this);
  `uvm_info("PROD", $sformatf("Data Sent : %0d", data), UVM_NONE); 
  port.put(data);
  phase.drop_objection(this);
endtask
endclass  
```  


**Consumer Code**   

```
class consumer extends uvm_component;
   `uvm_component_utils(consumer)


   uvm_blocking_put_export#(int) expo;
   subconsumer s;

   function new(input string path = "consumer", uvm_component parent = null);
     super.new(path, parent);
   endfunction


   virtual function void build_phase(uvm_phase phase);
   super.build_phase(phase);
   expo  = new("expo", this);
   s = subconsumer::type_id::create("s", this);
 endfunction


 virtual function void connect_phase(uvm_phase phase);
 super.connect_phase(phase);
 expo.connect(s.imp);
endfunction
endclass  
  
  

```

**Sub-Consumer Code**  
  
```  
class subconsumer extends uvm_component;
  `uvm_component_utils(subconsumer)


  uvm_blocking_put_imp#(int, subconsumer) imp;

  function new(input string path = "subconsumer", uvm_component parent = null);
    super.new(path, parent); 
  endfunction

  virtual function void build_phase(uvm_phase phase);
  super.build_phase(phase);
  imp   = new("imp", this);
endfunction

function void put(int datar);
  `uvm_info("SUBCONS", $sformatf("Data Rcvd : %0d", datar), UVM_NONE);
endfunction

 endclass 

```  
```
Example.5 - Tlm Port to Export to Imp 
```
  
In the above code example, we were using Producer as a Source, and it sent a data value is 9 using the syntax `uvm_blocking_put_port #(int) Port_handle_name`. then the Producer is transfer the data to Sub-Coumsumer through Coumsumer. and Consumer is sending and receives the data using syntax  `uvm_blocking_put_export#(int) port_handle_name`, then Sub-Consumer receives the data following Syntax `uvm_blocking_put_imp#(int, path) port_handle_name`. finally, Sub-consumer is receiving the data value is 9.      


* **Output**  

![Port_Export_Imp_ss](https://user-images.githubusercontent.com/106074838/200192904-300b6ef1-d7ba-4826-b25d-2d1332f8519f.png)  




         Fig.10- output for Port to Export to Imp  



**GitHub lab code link**: https://github.com/muneeb-mbytes/UVM_Course/blob/b7_Team_SiliconCrew/TLM/Port_Export_Imp/port_export_imp/port_export_imp.sv     

**GitHub log code link**: https://github.com/muneeb-mbytes/UVM_Course/blob/b7_Team_SiliconCrew/TLM/Port_Export_Imp/port_export_imp/port_export_imp.log     




   
## 4.Port to port to Export to Imp 


Sub_prod is a Subcomponent within the Producer that is trying to send transactions to another Subcomponent called sub-comps in Consumer. to maintain flexibility and portability of code, it is recommended to allow the sub-producer to send data to the consumer which should then forward them to the top layer of the hierarchy. consumer shall accept the transaction and forward it to Sub-consumer.   

Producer and Sub_producer are using the **port**. then consumer is using **Export** and finally sub_consumer is using **Imp**  

  
   


![Port_port_Export_Imp](https://user-images.githubusercontent.com/106074838/200193083-9a31a064-0c0b-46d1-a9b4-2c1113022284.png)  


                    Fig.11- Port to port to Export to Imp  

* **Code** 
  
  

**Sub Component**     
  
```
class sub_component1 extends uvm_component;
  int a=5;
     `uvm_component_utils(sub_component1)
     uvm_blocking_put_port#(int) sub_port;

     function new(string name="sub_component1",uvm_component parent=null);
       super.new(name,parent);
     endfunction
    
     virtual function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        sub_port= new("sub_port",this);
     endfunction 

     task run_phase(uvm_phase phase);
        phase.raise_objection(this);
        `uvm_info("s_c1",$sformatf("a: %0d",a),UVM_MEDIUM); 
        sub_port.put(a);
        phase.drop_objection(this);
     endtask

endclass

``` 

**Producer Code**  

```
class component1 extends uvm_component;
     
  `uvm_component_utils(component1)
     uvm_blocking_put_port#(int) port;
     sub_component1 s_c1;

     function new(string name="component1",uvm_component parent=null);
       super.new(name,parent);
     endfunction
    
     virtual function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        s_c1=sub_component1::type_id::create("s_c1",this);
        port= new("port",this);
     endfunction 

     virtual function void connect_phase(uvm_phase phase);
        super.connect_phase(phase);
        s_c1.sub_port.connect(this.port);
     endfunction

endclass
```   

**Consumer code**
  
 
  
``` 
 class sub_component2 extends uvm_component;
  `uvm_component_utils(sub_component2)
  uvm_blocking_put_imp#(int,sub_component2) imp;


  function new(string name="sub_component2",uvm_component parent=null);
    super.new(name,parent);
  endfunction
   
  
  virtual function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    imp=new("imp",this);
  endfunction 
  
  virtual task put(int b);
    #15 `uvm_info("s_c2",$sformatf("b: %0d",b),UVM_MEDIUM); 
  endtask
endclass

```

**Sub-Consumer**  

``` 
class component2 extends uvm_component;
    `uvm_component_utils(component2)
    uvm_blocking_put_export#(int) ex_port;
    sub_component2 s_c2;
    function new(string name="component2",uvm_component parent=null);
      super.new(name,parent);
    endfunction
     
  virtual function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    ex_port=new("ex_port",this);
    s_c2=sub_component2::type_id::create("s_c2",this);
  endfunction 
  
  virtual function void connect_phase(uvm_phase phase);
  super.connect_phase(phase);
  ex_port.connect(s_c2.imp);
  endfunction

endclass


```
```
Example.6 - Port to Port to Export to Imp
```  
In the above code example, we were using Producer as a Source, it sent a data value is 9 using the syntax `uvm_blocking_put_port#(int) Port_handle_name`.  
then the Sub-Producer is following this syntax `uvm_blocking_put_port#(int) Port_handle_name` and in the receiving part consumer is using this syntax `uvm_blocking_put_export#(int) Port_handle_name` and the sub-consumer is using `uvm_blocking_put_imp#(int,path) Port_handle_name`. finally, Sub-consumer is receiving the data value is 9.  

     
* **Output**  


![Port_port_Export_imp_ss](https://user-images.githubusercontent.com/106074838/200193189-9a4a0dfc-925b-46b0-833f-4f1c018736de.png)  

                Fig.12- output for Port to port to Export to Imp  



**GitHub lab code link:** https://github.com/muneeb-mbytes/UVM_Course/blob/b7_Team_SiliconCrew/TLM/Port_Export_Imp/port_port_export_imp/port_port_export_imp.sv  


**GitHub log code link:** https://github.com/muneeb-mbytes/UVM_Course/blob/b7_Team_SiliconCrew/TLM/Port_Export_Imp/port_port_export_imp/port_port_export_imp.log  



  

***

## TLM Get Port  
  
A component can request to receive the transaction from another component using the get port.  
Here, the consumer component will be implemented with the TLM get to port and the producer component will be implemented with the TLM get export. The implementation gives the sender a chance to define what needs to be sent to the requestor.  

![get_method drawio](https://user-images.githubusercontent.com/110443268/200162518-b6f085b8-81bc-40ec-8483-b201cf3b4d78.png)  

           Fig.13 - Block diagram for get method tlm ports 
  
 This is just the opposite of the put port which is studied above.  
Here also the port can be of two types-  
1. Blocking port  
2. Non-blocking port  

### Blocking get port  
The blocking get port is declared by -  
**Syntax-** `uvm_blocking_get_port #(packet) name;    // for port `   
 
           ` uvm_blocking_get_imp #(packet,class_name) name;   //for import `

For the uvm_blocking_get_port we only need to pass one argument which is the class name of the out transaction class where we are declaring our data, here packet is our transaction class name. In the case of uvm_blocking_get_imp, we need to pass only two arguments one is the transaction class name and the other is the class name where we are declaring the import port.  

For more clarity, let's consider below example-  
**Example**  
Step - 1: Create the transaction class for extends from the uvm_object class.  
**Code Snap**     
   
    class transaction extends uvm_object;     
      
    rand bit [3:0] a;   
    rand bit [4:0] b;   

    `uvm_object_utils_begin(transaction)   
    `uvm_field_int(a,UVM_DEFAULT)   
    `uvm_field_int(b,UVM_BIN)   
    `uvm_object_utils_end   

    function new (string st="transaction");   
    super.new(st);   
    endfunction   
    endclass   

 The above code snap is of transaction class extends from the uvm_object class.`uvm_object_utils(transaction) is used to register the class. Declaring two data members 'a' and 'b'.Function new is a constructor for transaction class.  

**Step-2**  
Now we need to write the code for the sender and receiver class for transferring the data using the TLM ports.  
**Code Snap**   

    class sender extends uvm_component;     
    `uvm_component_utils(sender);   
    uvm_blocking_get_imp #(transaction,sender) get_imp;   
    transaction trans;   
    function new ( string name ="sender",uvm_component parent = null);   
    super.new(name,parent);   
    endfunction   


    virtual function void build_phase(uvm_phase phase);   
    super.build_phase(phase);   
    get_imp=new("get_imp",this);   
    endfunction   

    virtual task get(output transaction trans);    
    trans=new();  // create new packet   
    void'(trans.randomize());   
    #5   

    `uvm_info("Sender","Reciever has requested for transaction",UVM_NONE);   
    trans.print(uvm_default_table_printer);   
    endtask   
    endclass   

Here the class 'sender' extends from uvm_component class which is used to send the transaction. The  uvm_blocking_get_imp  is used as a TLM port and passes two arguments#(transaction, sender)  one is the packet class and the other is the sender class name where the port is using #(transaction, sender). In the build_phase, we are building the import port. Declaring a task get() [build-in task] in which memory creation and randomization have occurred and then after 5ns, this class received the request from the receiver class. At last, data is printed in table format.  

**Step-3**  
The below code is for the receiving class.  
**Code Snap**  

     class receiver extends uvm_component;      
     `uvm_component_utils(receiver)      
     uvm_blocking_get_port #(transaction) get_port;         

     function new (string name ="receiver",uvm_component parent=null);      
     super.new(name,parent);      
     endfunction      

    virtual function void build_phase(uvm_phase phase);      
    get_port=new("get_port",this);      
    endfunction       

    virtual task run_phase(uvm_phase phase);      
    transaction trans;      
    phase.raise_objection(this);      
    for(int i=0;i<=4;i++)begin      
    get_port.get(trans);      
    `uvm_info("Reciever", "Just now received a transaction from the receiver",UVM_NONE)      
    phase.print(uvm_default_table_printer);      
    end      
    phase.drop_objection(this);      
    endtask       

    endclass      

Here, the receiving class getport is uvm_blocking_get_port to receive the transaction. The build phase is used to build the get port and the run phase is used to get the transaction from the sender. Inside the run phase,we are creating the objection and after getting the transaction drop the objection.  

**Step-4**  
Now need to create the connection between the sender and receiver  
**Code Snap**  
  
```
    class my_test extends uvm_test;    
    `uvm_component_utils(my_test)   
    sender sndr;   
    receiver rcvr;   
    function new(string name = "my_test",uvm_component parent =null);   
    super.new(name,parent);   
    endfunction   

    virtual function void build_phase(uvm_phase phase);   
    super.build_phase(phase);   

    sndr=sender::type_id::create("sndr",this);       
    rcvr=receiver::type_id::create("rcvr",this);   
    endfunction   

    //Connection between sender to receiver   
    virtual function void connect_phase(uvm_phase phase);   
    //super.connect_phase(phase);   
    rcvr.get_port.connect(sndr.get_imp);   
    endfunction   

    endclass   
```
```
Example.7 - Blocking TLM port   
```
Here, the my_test class is extended from uvm_test class. In the build_phase, we create sender and receiver class type_id using create method. For the connection between sender and receiver, we are using the connect phase.  

**Github Code link**: https://github.com/muneeb-mbytes/UVM_Course/blob/b7_Team_SiliconCrew/TLM/TLM_get_method/blocking_get/blocking_get.sv    

**Github log file link**: https://github.com/muneeb-mbytes/UVM_Course/blob/b7_Team_SiliconCrew/TLM/TLM_get_method/blocking_get/blocking_get_log.log   

**Output Snap** :   

The below output snap shows the receiver gets data packets for two times from the sender and time delay is also shows the blocking nature of port.    

<img width="926" alt="block" src="https://user-images.githubusercontent.com/110443268/200161553-30ce3172-4dc5-4919-aa7b-3b73d85258cc.png">

                    Fig.14 - Output for blocking TLM port 

***
### Non-blocking TLM getport  
The non_blocking get port is declared by -
**Syntax-**  
`uvm_nonblocking_port #(transaction) name_of_port`   
       or 
`uvm_nonblocking_exp #(transaction,class_name) name_of_port`  
  
For using the non-blocking ports we should know two methods and these are -  
**1.try_get**  
The sender tries to see get is successful or not.  
 
**2.can_get**
See if the seder is ready to transfer or not.  

**Using try_get method**  
Firstly create a transaction class for data packets.  Same as above step-1 for blocking get method.  
After that, we need to create a sender class which sends the transaction. Let's see the below code -
**Code Snap**  

     // Creating a sender class which extends uvm_component class   
     class sender extends uvm_component;   
     `uvm_component_utils(sender);   
     uvm_nonblocking_get_imp #(transaction,sender) get_imp;   
     transaction trans;   
     function new ( string name ="sender",uvm_component parent = null);   
     super.new(name,parent);   
     endfunction   


     virtual function void build_phase(uvm_phase phase);   
     super.build_phase(phase);   
     get_imp=new("get_imp",this);   
     endfunction   

     virtual function bit try_get(output transaction trans);   
     trans=new();  // create new packet   

     void'(trans.randomize());   
     `uvm_info("Sender","receiver has requested for the transaction",UVM_NONE);   
     trans.print(uvm_default_table_printer);   
     return 1;   
     endfunction         

     virtual function bit can_get();   
     endfunction   

     endclass   

In the above code, declaring one non-blocking port which is uvm_nonblocking_imp. As the try_get method is a function, we can not give a delay inside it and hence it will not show any blocking behaviour. After receiving a request from the receiver it will send the transactions. 
  
After declaring the sender component, now need to create a receiver component class. The below code is for the receiver component which also extends from uvm_component class.   
      
**Code Snap**  

```    
    // Creating a receiver class  
    class receiver extends uvm_component;   
    `uvm_component_utils(receiver)   
    uvm_nonblocking_get_port #(transaction) get_port;   

    function new (string name ="receiver",uvm_component parent=null);   
    super.new(name,parent);   
    endfunction   

    virtual function void build_phase(uvm_phase phase);   
    super.build_phase(phase);   
    get_port=new("get_port",this);   
    endfunction   

    virtual task run_phase(uvm_phase phase);   
    transaction trans;   
    phase.raise_objection(this);   
    for(int i=0;i<=4;i++)begin   
    if(get_port.try_get(trans))   
    `uvm_info("receiver","Just now received transaction from receiver",UVM_NONE)         
    else   
    `uvm_info("receiver", "Transaction not received",UVM_NONE)      

    phase.print(uvm_default_table_printer);      
    `uvm_info("receiver", "DONE",UVM_NONE)   
    end   
    phase.drop_objection(this);   
    endtask   

    endclass    
```
```
Example.8 - Non-Blocking Tlm port using try method  
```

  The above is for the receiver component. In the run_phase, here we are using for loop for getting the transaction 2 times if the sender sends the transaction.  

**Github Code link**: https://github.com/muneeb-mbytes/UVM_Course/blob/b7_Team_SiliconCrew/TLM/TLM_get_method/non_blocking_get/non_blocking_get/non_blocking_get.sv      

**Github log file link**:  https://github.com/muneeb-mbytes/UVM_Course/blob/b7_Team_SiliconCrew/TLM/TLM_get_method/non_blocking_get/non_blocking_get/non_blocking_get_log.log    

**Output Snap**  
The below output snap shows that first receiver has to request for transaction data then only will send tor transfer the data.  


<img width="903" alt="try" src="https://user-images.githubusercontent.com/110443268/200161570-7d516d2e-6b05-408d-a85a-eb87df8f90fe.png">
                     
                                Fig.15 - Output of TLM get port using non_blocking try method  

**Using can_get method**  
In this method, to see whether the sender is ready to transfer the data packets or not.  
Instead of directly trying to get the packet the receiver can first see whether the sender is ready or not. Below code snap for the sender and receiver component gives a clear idea about the can_get method.    
Sender component code-  

**Code Snap**  

    // Creating a sender class which extends uvm_component class   
    class sender extends uvm_component;   
    `uvm_component_utils(sender);   
    uvm_nonblocking_get_imp #(transaction,sender) get_imp;   
    transaction trans;   
    function new ( string name ="sender",uvm_component parent = null);   
    super.new(name,parent);   
    endfunction   


    virtual function void build_phase(uvm_phase phase);   
    super.build_phase(phase);   
    get_imp=new("get_imp",this);     
    endfunction   

    virtual function bit try_get(output transaction trans);     
    trans=new();  // create new packet   

    void'(trans.randomize());   
    `uvm_info("Sender","Reciever has requested for the transaction",UVM_NONE);   
    trans.print(uvm_default_table_printer);   
    return 1;   
    endfunction   

    virtual function bit can_get();   
    bit ready;     
    void'( std::randomize(ready)with{ready dist{0:/80,1:/10};});   
    return ready;   
    endfunction      

    endclass   

Here the function can_get is using the inline constraint for weight distribution. So that it will create the probability concept for data packets occurring.  




Now, code for receiving component.  

**Code snap**  

```
    // Creating a receiver class   
    class receiver extends uvm_component;   
    `uvm_component_utils(receiver)   
    uvm_nonblocking_get_port #(transaction) get_port;   

    function new (string name ="receiver",uvm_component parent=null);   
    super.new(name,parent);   
    endfunction      

    virtual function void build_phase(uvm_phase phase);   
    super.build_phase(phase);   
    get_port=new("get_port",this);   
    endfunction   

    virtual task run_phase(uvm_phase phase);   
    transaction trans;   
    phase.raise_objection(this);   
    for(int i=0;i<=4;i++)begin   
    while(!get_port.can_get())begin   
    #10 `uvm_info("Reciever","Check can_get() is ready",UVM_NONE)      
    end      
    `uvm_info("Receiver","Sender is ready,get transaction now",UVM_NONE)      
    if(get_port.try_get(trans))   
    `uvm_info("Reciever","Just now received transaction from receiver",UVM_NONE)   
    else   
    `uvm_info("Receiver","Transaction not received",UVM_NONE)        

    phase.print(uvm_default_table_printer);   
    `uvm_info("Reciever","DONE",UVM_NONE)   
    end  
    phase.drop_objection(this);   
    endtask      
    endclass   
```
```
Example.9 - Non-Blocking get port using can_get method   
```
The above code shows the working of receiving component.  

 **Github Code link**: https://github.com/muneeb-mbytes/UVM_Course/blob/b7_Team_SiliconCrew/TLM/TLM_get_method/non_blocking_get/non_blocking_get_can/non_blocking_get_can.sv   

**Github log file link**:  https://github.com/muneeb-mbytes/UVM_Course/blob/b7_Team_SiliconCrew/TLM/TLM_get_method/non_blocking_get/non_blocking_get_can/non_blocking_get_can.log     

**Output Snap**  
  
<img width="920" alt="can1" src="https://user-images.githubusercontent.com/110443268/200185263-d71a21f8-590e-4ea7-a7d4-523aef7fb881.png">
<img width="916" alt="can2" src="https://user-images.githubusercontent.com/110443268/200185265-afab3f40-5ff6-4454-841e-2842232b31c6.png">
 
                             Fig.16 :Output for can_get port method
The above snap is for the output of the can_get method.    



***


## **TLM FIFO**

When two components are working as Initiators, the FIFO is used as a storage device that stores the data temporarily.    
Let us consider ComponentA and ComponentB as two Components. Now the componentA may generate multiple transactions while ComponentB is still working on a single transaction. In this scenario, FIFO is used to store data temporarily without any loss in the data.  

The transactions given by ComponentA are temporarily stored in **TLM-FIFO** and given one by one to ComponentB.


![image](https://user-images.githubusercontent.com/113416951/200227981-5b3e6bf3-49e7-458b-8fe6-a67da7910a5e.png)  

```
Fig.17 - TLM fifo connections between two components  
```

Both the ports in Component A and Component B are connected to the exports in TLM_FIFO.

As explained above Component A, and Component B both acts as initiators. componentA, ComponentB has a Port where the port initiates the transaction. The FIFO has export pins where it responds to the request of the port.
    

**Code Snippet**:

```
            `include "uvm_macros.svh"
             import uvm_pkg::*;
 
             class packet extends uvm_sequence_item;
             rand bit[2:0]a;
             rand bit[3:0]b;
             `uvm_object_utils_begin(packet)
             `uvm_field_int(a,UVM_ALL_ON)
             `uvm_field_int(b,UVM_ALL_ON)
             `uvm_object_utils_end
              function new(input string name="packet");
              super.new(name);
              endfunction
              endclass 

              class componentA extends uvm_component;
              `uvm_component_utils(componentA)
               packet p;
               uvm_blocking_put_port #(packet) port;

               function new(input string name="componentA",uvm_component parent=null);
               super.new(name,parent);
               endfunction

               virtual function void build_phase(uvm_phase phase);
               super.build_phase(phase);
               port=new("port",this);
               endfunction

               virtual task run_phase(uvm_phase phase);
               phase.raise_objection(this);
               repeat(2) begin
               p=packet::type_id::create("p");
               assert(p.randomize());
               #1 port.put(p);
               p.print ();
               `uvm_info("componentA", "packet sent to componentB", UVM_MEDIUM)
               end
               phase.drop_objection(this);
               endtask
               endclass

               class componentB extends uvm_component;
               `uvm_component_utils(componentB)
                packet p;
                uvm_blocking_get_port #(packet) port1;


                function new(input string name="componentB",uvm_component  parent=null);
                super.new(name,parent);
                endfunction

                virtual function void build_phase(uvm_phase phase);
                super.build_phase(phase);
                port1=new("port1",this);
                endfunction

                virtual task run_phase(uvm_phase phase);
                phase.raise_objection(this);
                repeat(2) begin

                #4 port1.get(p);

                p.print();
                `uvm_info("componentB", "received packet from componentA", UVM_MEDIUM)
                end
                phase.drop_objection(this);
                endtask
                endclass

                class my_test extends uvm_test;
                `uvm_component_utils(my_test)
                 componentA compA;
                 componentB compB;
                 uvm_tlm_fifo #(packet) m_tlm_fifo;

                 function new(input string name="my_test",uvm_component parent=null);
                 super.new(name,parent);
                 endfunction

                 virtual function void build_phase(uvm_phase phase);
                 super.build_phase(phase);
                 compA=componentA::type_id::create("compA",this);
                 compB=componentB::type_id::create("compB",this);
                 m_tlm_fifo=new("uvm_tlm_fifo", this,2);
                 endfunction

                 virtual function void connect_phase(uvm_phase phase);
                 compA.port.connect(m_tlm_fifo.put_export);
                 compB.port1.connect(m_tlm_fifo.get_export);
                 endfunction

                 virtual task run_phase(uvm_phase phase);
                 forever
                 begin
                 if(m_tlm_fifo.is_full())
                 begin
                 #1   `uvm_info("tlm_fifo","fifo is full",UVM_MEDIUM)
                 end
                 else
                 begin
                 #1  `uvm_info("tlm_fifo","fifo is empty",UVM_MEDIUM)
                 end
                 end
                 endtask
                 endclass

                 module tb;
                 initial
                 begin
                 run_test("my_test");
                 end
                 endmodule
```
```
Example.10 - Code for Tlm Fifo  
```  

The connection between two components via a **TLM_FIFO** is done at a higher hierarchical level. Since both the components are directly instantiated within the class, the connection between them can be done during the connect_phase of the test.    

UVM TLM_FIFO in this example is defined to have a depth of 2. The **put_export** is connected to the ComponentA **put** port and the **get_export** is connected to the ComponentB **get** port.

**Output Snap:-**

![tlm1p drawio](https://user-images.githubusercontent.com/113416951/200240372-fdb220c8-d048-4346-a57f-e94b80711f36.png)

![TLM2 drawio](https://user-images.githubusercontent.com/113416951/200244606-2e7958ff-a0c2-4ecb-993d-6ef936d6866d.png)

![TLMA drawio (1)](https://user-images.githubusercontent.com/113416951/200245390-80753b1f-0685-4e53-b81d-2bee16797329.png)

![TLM drawio](https://user-images.githubusercontent.com/113416951/200245746-8a7dfc94-2ecc-4902-9f86-b85e0ffadab9.png)

```
Fig.18 -  Output screenshots for fifo usage in between ports  
```
In the output it is observed fifo is becoming full at 4ns.

**GitHub code link:** https://github.com/muneeb-mbytes/UVM_Course/blob/b7_Team_SiliconCrew/TLM/TLM_fifo/tlm_fifo.sv  

**GitHub log file link:**  https://github.com/muneeb-mbytes/UVM_Course/blob/b7_Team_SiliconCrew/TLM/TLM_fifo/tlm_fifo_log.log  



***

## UVM TLM EXAMPLE  

This UVM TLM example uses put ports, get ports, and TLM FIFOs to build a testbench that has TLM ports at different levels.

![Capture](https://user-images.githubusercontent.com/110412468/200254482-f5f8e54b-3fa2-48cc-9984-758921653da9.PNG)  

                        Fig.19 - Image of components with tlm ports & tlm fifo .

### Packet
A class called "packet" will be transferred to all the components of the testbench. It has two variables 'a' and 'b' that will be randomized before sending.  

```
class packet extends uvm_object;
  rand bit[3:0] a;
  rand bit[2:0] b;

  `uvm_object_utils_begin(packet)
  `uvm_field_int(a,UVM_ALL_ON)
  `uvm_field_int(b,UVM_ALL_ON)
  `uvm_object_utils_end

  function new(string name="packet");
    super.new(name);
  endfunction

endclass
```  
### Subcomponent1
A class called 'subcomp1' is created that uses 'uvm_blocking_put_port' that accepts a data object of the packet and randomized and sent via put port handle by calling put() method. Many such packets can be sent via a simple repeat loop.

```
class subcomp1 extends uvm_component;
  `uvm_component_utils(subcomp1)

  uvm_blocking_put_port#(packet) m_put_port;
  int m_tx;

  function new(string name="subcomp1",uvm_component parent=null);
    super.new(name,parent);
  endfunction

  virtual function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    m_put_port=new("m_put_port",this);
  endfunction

  virtual task run_phase(uvm_phase phase);

    repeat(m_tx) begin
      packet pkt=packet::type_id::create("pkt");
      void'(pkt.randomize());
      #50;
      `uvm_info("subcomp1", "Packet sent to ComponentA of TLM FIFO", UVM_LOW);
      pkt.print(uvm_default_line_printer);
      m_put_port.put(pkt);
      `uvm_info("subcomp1","done",UVM_LOW);
    end

  endtask
endclass
```  
### componentA
The class componentA has subcomponent1 that has connected to the TLM FIFO of depth 2 since componentA and componentB transfer rates are different. The componentA uses the uvm_blocking_get_export to transfer the packet to the componentB. At every 40ns the TLM FIFO is checked for whether it is full or not.
```
class componentA extends uvm_component;
  `uvm_component_utils(componentA)

  function new(string name="componentA",uvm_component parent=null);
    super.new(name,parent);
  endfunction

  subcomp1 m_comp1;
  int m_tx;

  uvm_tlm_fifo#(packet) m_tlm_fifo;
  uvm_blocking_get_export#(packet) m_get_export;

  virtual function void build_phase(uvm_phase phase);
    super.build_phase(phase);

    m_comp1 = subcomp1::type_id::create("m_comp1",this);
    m_tlm_fifo = new("m_tlm_fifo",this,2);
    m_get_export = new("m_get_export",this);
    m_comp1.m_tx = m_tx;

  endfunction

  virtual function void connect_phase(uvm_phase phase);
    super.connect_phase(phase);
    m_comp1.m_put_port.connect(m_tlm_fifo.put_export);
    this.m_get_export.connect(m_tlm_fifo.get_export);
 endfunction

  virtual task run_phase(uvm_phase phase);
    forever begin
      #40 if(m_tlm_fifo.is_full())
            `uvm_info("COMPA", "component A: TLM FIFO is full!", UVM_MEDIUM);
          end
   endtask

 endclass
```  
### subcomponent2
The class subcomp2 is created and has the delay to get the packet and uses the uvm_blocking_get_port to get the data of type packet at every 100ns and transfer it through uvm_blocking_put_port.

```
class subcomp2 extends uvm_component;
 `uvm_component_utils(subcomp2)

  function new(string name="subcomp2",uvm_component parent=null);
    super.new("name",parent);
  endfunction

  uvm_blocking_get_port#(packet) m_get_port;
  uvm_blocking_put_port#(packet) m_put_port;
  int m_tx;

  virtual function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    m_get_port = new("m_get_port",this);
    m_put_port = new("m_put_port",this);
  endfunction

  virtual task run_phase(uvm_phase phase);
    packet pkt;
    repeat(m_tx) begin
      #100;
      m_get_port.get(pkt);
      `uvm_info("SUBCOMP2", "packet received from component A", UVM_LOW);
     pkt.print(uvm_default_line_printer);
      m_put_port.put(pkt);
      `uvm_info("SUBCOMP2","subcomp2 is done",UVM_MEDIUM);
    end
  endtask

endclass
```  
### subcomponent3  

Subcomponent3 has a slight delay than the other components. It uses the uvm_blocking_get_port to get the data at every 200ns. 

```
class subcomp3 extends uvm_component;
  `uvm_component_utils(subcomp3)

  function new(string name="subcomp3",uvm_component parent);
    super.new(name,parent);
  endfunction

  uvm_blocking_get_port#(packet) m_get_port;

  virtual function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    m_get_port = new("m_get_port",this);
  endfunction

  virtual task run_phase(uvm_phase phase);
    packet pkt;
    forever begin
      #200;
      m_get_port.get(pkt);
      `uvm_info("SUBCOMP3","packet recieved from component B of tlm fifo",UVM_MEDIUM);
      pkt.print(uvm_default_line_printer);
      `uvm_info("SUBCOMP3","subcomp3 is done",UVM_MEDIUM);
    end
  endtask

endclass
```  
### componentB
The class componentB has 2 subcomponents subcomp2 and subcomp3 and one TLM FIFO in between the two subcomponents because these two subcomponents has different transfer rates. The componentB uses uvm_tlm_fifo port for TLM FIFO and uvm_blocking_get_port to get the data packets from componentA. Here also the TLM FIFO is checked whether it is full or not for every 50ns.
```
class componentB extends uvm_component;
  `uvm_component_utils(componentB)

  function new(string name = "componentB",uvm_component parent = null);
    super.new(name,parent);
  endfunction

  uvm_tlm_fifo#(packet) m_tlm_fifo;
  uvm_blocking_get_port#(packet) m_get_port;
  subcomp2 comp2;
  subcomp3 comp3;
  int m_tx;

  virtual function void build_phase(uvm_phase phase);
  super.build_phase(phase);
  comp2 = subcomp2::type_id::create("comp2",this);
  comp3 = subcomp3::type_id::create("comp3",this);
  m_tlm_fifo = new("m_tlm_fifo",this,2);
  m_get_port = new("m_get_port",this);
  comp2.m_tx = m_tx;
endfunction

virtual function void connect_phase(uvm_phase phase);
  super.connect_phase(phase);
  comp2.m_get_port.connect(this.m_get_port);
  comp2.m_put_port.connect(m_tlm_fifo.put_export);
  comp3.m_get_port.connect(m_tlm_fifo.get_export);
endfunction

  virtual task run_phase(uvm_phase phase);

  forever begin
    #50 if(m_tlm_fifo.is_full())
      `uvm_info("COMPB","COMPONENT B: TLM FIFO is full!",UVM_MEDIUM);
    end

  endtask
endclass
```  
### ENV
The env class is the top level class in which componentA and componentB are instantiated directly within this class. In this example the connection between the both components can be done in the connect phase of the env.  
```
class env extends uvm_env;
  `uvm_component_utils(env)

  function new(string name = "env",uvm_component parent = null);
    super.new(name,parent);
  endfunction

  componentA compA;
  componentB compB;
  int m_tx;

  virtual function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    compA = componentA::type_id::create("compA",this);
    compB = componentB::type_id::create("compB",this);
    std::randomize(m_tx) with {m_tx inside {3};};
    `uvm_info("ENV",$sformatf("created %0d packets in total",m_tx),UVM_LOW);
    compA.m_tx = m_tx;
    compB.m_tx = m_tx;
  endfunction

  virtual function void connect_phase(uvm_phase phase);
  super.connect_phase(phase);
compB.m_get_port.connect(compA.m_get_export);
endfunction

  virtual task run_phase(uvm_phase phase);
    super.run_phase(phase);
    phase.raise_objection(this);
    #5000;
    phase.drop_objection(this);
  endtask

endclass
```  
### module
Testbench module is initiated in the following code.
``` 
`include "uvm_macros.svh"
import uvm_pkg::*;

`include "packet.sv"
`include "subcomp1.sv"
`include "componentA.sv"
`include "subcomp2.sv"
`include "subcomp3.sv"
`include "componentB.sv"
`include "environment.sv"

module tb;
initial begin
  run_test("env");
end
endmodule
```  
```
Example.11 - Code for general TLM Example including Tlm fifo  
```


**GitHub code link:** https://github.com/muneeb-mbytes/UVM_Course/tree/b7_Team_SiliconCrew/TLM/TLM_example  

**GitHub log file link:** https://github.com/muneeb-mbytes/UVM_Course/blob/b7_Team_SiliconCrew/TLM/TLM_example/TLM_Example.log  

**output:**  

![1](https://user-images.githubusercontent.com/110412468/200254598-34efb3cf-bc77-4bb2-9dea-eb5015390081.PNG)

 

                                Fig.20 - Output image  

As per the code, the 3 packets are generated and sent from the subcomp1 to componentA: TLM FIFO for every 50ns. S0 at each 50,100 and 150ns the packets are forwarded from subcomp1 to componentA: TLM FIFO. Subcomponent2 receives these packets one by one at every 100ns. So the three packets are received to the subcomponent2 at 100,200 and 300ns. Then the subcomponent2 forwarded these packets to componentB: TLM FIFO. Subcomponent3 receives the packets at every 200ns. So the three packets are received to the subcomponent3 at 200,400 and 600ns. The TLM FIFOs(depth 2) of componentA and componentB are checked for full or not for every 40ns and 50ns respectively. So here the componentA: TLM FIFO is full at 160ns. The component: TLM FIFO is full at 300 and 350ns.   





***  

## TLM Analysis port  

Earlier we have seen TLM `put()` and `get()` methods which was having one-on-one connections that is either port-to-export or port-to-imp connections. whereas this analysis port are used for one-to many connections that is broadcast of transactions to any number of components or receivers(even if there is no receiver analysis port broadcasts the data). hence we can conclude it as analysis port may be connected to zero, one or many Analysis Exports.    

![Analysis port](https://user-images.githubusercontent.com/113417083/200270243-95c6fea9-fd0b-4750-baab-e1a64a0c3f4f.png)  

```
Fig.21 - Image of Components with Analysis ports  
```

`uvm_analysis_port` : **Broadcast port**

The uvm_analysis_port is a specialized TLM port which has non-blocking function, write(). The uvm_analysis_port calls an analysis_port.write(transaction) method to broadcast a transaction. A uvm_analysis_port can be connected to other uvm_analysis_ports, uvm_analysis_exports and uvm_analysis_imps.

`uvm_analysis_export` : **Transfer port**

The uvm_analysis_export is similar to a transferpoint connection and it lies between the broadcasting uvm_analysis_port source and each uvm_analysis_imp termination point. uvm_analysis_export(s) can be viewed as a transfer port.

`uvm_analysis_imp` : **Termination port**

Each uvm_analysis_imp defines a `write() `method that is executed when the analysis port calls the write() method. In the parent environment, the analysis port gets connected to the analysis export of the desired components, such as coverage collectors and scoreboards in a typical UVM testbench.       

The uvm_analysis_port is a specialized TLM class which consists of a function `write()` and this can be used to transfer the data from where we need. This port also contains list of analysis exports and analysis implementations that are connected to it. Later by using the analysis_port.write() in one component we can broadcast the data to each connected exports. Components which have a `read()` function will receive the datas which are broadcasted.
Generally monitor will be using analysis_port to broadcast the data to multiple components like scoreboard, coverage collector, subscribers.    
 
* **Syntax:**  

          class my_class_name extends uvm_component;   
                   .....   
                 uvm_analysis_port #(my_data) port_name;   
                   .....   
           endclass    

**Example:**

![analysis-port](https://user-images.githubusercontent.com/113417083/200236277-8a0a0352-f8c5-4201-b92a-26bb2ac1775a.gif)    
```
Gif.2 - Broadcasting of data through Analysis port
```

In this example, let us consider a componentB from which we broadcast or send the data to three different subscribers (sub1,sub2,sub3). Since we need to perform broadcasting of the data ,we use a special type of connection called uvm_analysis_port. 

**Producer Class** 

          class transaction extends uvm_sequence_item;
              rand bit[2:0]a;
              rand bit[2:0]b;

            `uvm_object_utils_begin(transaction)
            `uvm_field_int(a,UVM_DEFAULT+UVM_DEC)
            `uvm_field_int(b,UVM_DEFAULT+UVM_DEC)
            `uvm_object_utils_end


            function new (string name = "transaction");
                super.new(name);
            endfunction

        endclass

        class componentB extends uvm_component;

             `uvm_component_utils(componentB)

              transaction trans;
             uvm_analysis_port #(transaction) ap;

             function new (string name = "componentB" , uvm_component parent);
                  super.new (name,parent);
                  ap = new("WRITE",this);
             endfunction

            virtual function void build_phase(uvm_phase phase);
                 super.build_phase(phase);
                 trans = transaction::type_id::create("trans",this);
           endfunction

           virtual task run_phase(uvm_phase phase);
                repeat(3) begin
                `uvm_info(get_type_name(),"sending Data to subscribers.......",UVM_NONE)
                void'(trans.randomize());
                ap.write(trans);
                trans.print();
                 end
          endtask

      endclass

In the above code snippet, we are extending transaction class from uvm_sequence_item which is a base class. we defined two class properties 'a' and 'b' of rand bit type. since uvm_sequence_item is a object, we registered this class using pre-defined factory macro uvm_component_utils and the fields are also registered within this factory registration. 

We have defined a class componentB extending from uvm_component. This class is registered using factory macro. Now, in this example we are defining a special type of port called uvm_analysis_port. After declaring some random_name('ap') to analysis_port, we have to specify that port operations as write(to specify this as a producer). using ap.write(trans) we broadcasted the data from the componentB.   

**Consumer Classes**  

          class sub1 extends uvm_component;
             transaction trans;

             `uvm_component_utils(sub1)
              uvm_analysis_imp #(transaction , sub1) aimp;

              function new (string name = "sub1" , uvm_component parent);
                    super.new (name,parent);
                     aimp = new("READ",this);
              endfunction
      
              virtual function void write (input transaction t);
                   t.print();
                   `uvm_info(get_type_name(),"Data Received to sub1!!",UVM_NONE)
              endfunction
           endclass

             class sub2 extends uvm_component;
                  transaction trans;
                 `uvm_component_utils(sub2)
                  uvm_analysis_imp #(transaction , sub2) aimp;

                  function new (string name = "sub2" , uvm_component parent);
                          super.new (name,parent);
                          aimp = new("READ",this);
                  endfunction

                  virtual function void write (input transaction t);
                          t.print();
                         `uvm_info(get_type_name(),"Data Received to sub2!!",UVM_NONE)
                 endfunction
             endclass


            class sub3 extends uvm_component;
                   transaction trans;
                   `uvm_component_utils(sub3)
                   uvm_analysis_imp #(transaction , sub3) aimp;

                  function new (string name = "sub2" , uvm_component parent);
                      super.new (name,parent);
                      aimp = new("READ",this);
                  endfunction

                  virtual function void write (input transaction t);
                        t.print();
                       `uvm_info(get_type_name(),"Data Received to sub3!!",UVM_NONE)
                   endfunction
                endclass

We extended 3 different class sub1,sub2 and sub3 from uvm_component. Since this class need to receive the datas which are broadcasted from componentB we are defining a uvm_analysis_imp with a name as 'aimp' and during its build phase we are declaring this port as `READ` type(consuming type). We have defined a virtual function with name as write and we are passing the transaction as an argument to it. This is similar for all 3 consumer classes.

```
          class my_env extends uvm_env;
              componentB  comB;
              sub1 s1;
              sub2 s2;
               sub3 s3;
              `uvm_component_utils(my_env)

              function new (string name = "my_env" , uvm_component parent);
                super.new (name,parent);
              endfunction

             virtual function void build_phase (uvm_phase phase);
                super.build_phase(phase);
                comB = componentB::type_id::create("comB",this);
                s1 = sub1::type_id::create("s1",this);
                s2 = sub2::type_id::create("s2",this);
                s3 = sub3::type_id::create("s3",this);
             endfunction

              virtual function void connect_phase (uvm_phase phase);
                super.connect_phase(phase);
                comB.ap.connect(s1.aimp);
                comB.ap.connect(s2.aimp);
               comB.ap.connect(s3.aimp);
            endfunction
         endclass

            class test extends uvm_test;
                my_env env;
                `uvm_component_utils(test)

                 function new (string name = "test" , uvm_component parent);
                       super.new (name,parent);
                 endfunction

                 virtual function void build_phase(uvm_phase phase);
                        super.build_phase(phase);
                        env = my_env::type_id::create("env",this);
                 endfunction

                 virtual function void end_of_elaboration_phase(uvm_phase phase);
                             super.end_of_elaboration_phase(phase);
                            `uvm_info(get_type_name(),"end_of_elaboration_phase",UVM_NONE)
                            uvm_top.print_topology();
                  endfunction
           endclass
```
```
Example.12 - Code for Analysis port   
```

**GitHub code link:** https://github.com/muneeb-mbytes/UVM_Course/blob/b7_Team_SiliconCrew/TLM/Analysis_port/analysis_port.sv  

**GitHub log file link:** https://github.com/muneeb-mbytes/UVM_Course/blob/b7_Team_SiliconCrew/TLM/Analysis_port/analysis_port_log.log   

We extended my_env class from uvm_env and instantiated the producer and the consumer classes with a name and also at this level it is very easier to have connection between the components.So, we created object for the instantiated classes during the build_phase and during the connect phase we connected the producer_port to the consumer_port.

Finally we extended the test class from uvm_test and we instatiated and created a object using create method for derived env class. Also during `end_of_elaboration_phase` we are printing the whole topology which includes the name of derived class and the base class. 

* **Output:**


![topo](https://user-images.githubusercontent.com/110412468/200274962-a9628901-4afa-472a-945f-27a3ac393fdd.PNG)

![iter1](https://user-images.githubusercontent.com/110412468/200274991-57b7a191-b380-4dd4-897c-c8450c517f11.PNG)

```
Fig.22 - Output screenshots for usage of Analysis port  
```


From the above output snaps, we can see that componentB is sending the data to consumers and all 3 consumers are driving or receiving the same output from componentB.  





***  

## TLM Sockets  

 The socket enables asynchronous bi-directional data transfer between the initiator and the target component. A socket is like a port or export, in fact, it is derived from the same base class as ports and export. Components that initiate transactions are called initiators, and components that receive transactions sent by an initiator are called targets.  Initiators have initiator sockets and targets have target sockets. However, unlike a port or export, a socket provides both a forward and backward path.  Thus you can enable asynchronous bi-directional communication by connecting sockets together.  To enable this, a socket contains both a port and an export.      
 You cannot connect initiator sockets to other initiator sockets and you cannot connect target sockets to target sockets.  
  

* **Syntax:**  

`uvm_tlm_b_initiator_socket#(sequence_class_name) socket_handle_name`   
 
`uvm_tlm_b_target_socket#(sequence_class_name) socket_handle_name`

![dddd-Page-2 drawio](https://user-images.githubusercontent.com/110447788/200242991-ef2305cf-aa24-4317-9b62-6821395a2d4e.png)  
```
Fig.23 - Components with sockets 
```

**Code Snippet:**      

```
                  class initiator extends uvm_component;

                 `uvm_component_utils(initiator)

                  uvm_tlm_time delay;
                  seq_item req;

                  // Declare a blocking initiator socket
                  uvm_tlm_b_initiator_socket #(seq_item) socket_i;

                  function new(string name = "initiator", uvm_component parent = null);
                  super.new(name, parent);
                  endfunction

                  function void build_phase(uvm_phase phase);
                  super.build_phase(phase);
                  //Create an instance of the socket
                  socket_i = new("socket_i", this);
                  delay = new("delay");
                  endfunction

                  task run_phase(uvm_phase phase);
                  super.run_phase(phase);
                  repeat(2) begin
                  req = seq_item::type_id::create("req");
                  assert(req.randomize());
                  `uvm_info(get_name(), $sformatf("Send req =\n%0s", req.sprint() ), UVM_NONE);
                  // Use the socket to sent data
                  socket_i.b_transport(req,delay);
                  end
                  endtask
                  endclass


                 class target extends uvm_component;
                 `uvm_component_utils(target)

                 // Declare a blocking target socket
                 uvm_tlm_b_target_socket #(target, seq_item) socket_t;

                 function new(string name = "target", uvm_component parent = null);
                  super.new(name, parent);
                //Create an instance of the target socket
                 socket_t = new("socket_t", this);
                 endfunction

                virtual task b_transport(seq_item req, uvm_tlm_time tlm_delay);
               `uvm_info(get_type_name(), $sformatf("Received payload =\n%s", req.sprint()), UVM_NONE);
                endtask
                endclass
```
```
Example.13 - Code for Tlm Sockets    
```

In this example, we are using tlm sockets which enable the bidirectional data transfer between the initiator and target component. Here, we are creating a seq_item class by extending the uvm_sequence_item class which is already present in the object class. Using `uvm_object_utils we are registering our "seq_item" class. Then, create the constructor [function new()]for the class "seq_item".       
Here, we are declaring an initiator class by extending uvm_component. Using uvm_component_utils we are registering the initiator class. In the initiator class, we are declaring a blocking initiator socket by **uvm_tlm_b_initiator_socket**  and then create the constructor [function new()] for the class initiator.  Create them in the build phase and connect them in the connect phase by calling connect().  In the build_phase we are creating an instance of the socket. In the run_phase let us generate 2 packets and sent them via socket and here we are using socket to send the data.  
Here, we are declaring a target class by extending uvm_component. Using uvm_component_utils we are registering the target class. Then, create the constructor [function new()]for the class "target". Here, we are declaring a blocking target socket by **uvm_tlm_b_target_socket** and creating an instance of the target socket.  

**Output Snap:**

![dddd drawio](https://user-images.githubusercontent.com/110447788/200241569-ff9ca1e0-4d89-4b12-96eb-22a6efcc436d.png)  

```
Fig.24 - Output for usage of TLM Sockets  
```

 In the above output, we are transferring the data between the initiator and target with the help of tlm sockets. Here there are three variables a, b, and c in which a and b are random variables. Here, we are transferring the data with the help of the initiator and target of tlm sockets.

**GitHub code link:** https://github.com/muneeb-mbytes/UVM_Course/blob/b7_Team_SiliconCrew/TLM/tlm_sockets/tlm_sockets.sv  

**GitHub log file link:** https://github.com/muneeb-mbytes/UVM_Course/blob/b7_Team_SiliconCrew/TLM/tlm_sockets/tlm_sockets.log  


***  

# TLM decl macros

In `TLM Put`, we have seen the scenario, where data sent to the consumer is executed using the `put()` method. Let us consider the case where there are two producers A and B connected to consumer export. Then, any data object sent by either producer A or producer B will be received by the consumer and operated upon by the same `put()` method. If there's a need to be able to process them separately, you would need to have two separate `put()` methods.  

![TLM1 drawio](https://user-images.githubusercontent.com/113421192/200131612-6642316e-ce45-4414-93c4-58230b88e230.png)   
```
Fig.25 - Multiple incoming data producers for single receiver  with single export  
```


UVM provides us with the `uvm_*_put_imp_decl ()` macro to deal with cases when the producer needs to provide two put implementation ports.   


* **Sample code:**  

      `uvm_put_imp_decl (_1)  
      `uvm_put_imp_decl (_2)  
    
       class consumer extends uvm_component
        uvm_put_imp_1 (packet, consumer) put_imp1;
        uvm_put_imp_2(packet, consumer) put_imp2;
  
      function void put_1(packet pkt);
        //puts coming from put_imp1
      endfunction
   
      function void put_2(packet pkt);
        //puts coming from put_imp2
      endfunction

      endclass

**Note:**  
    
* `'uvm_put_imp_decl` should be outside the class.  
* `uvm_put_imp` class used consumer should have the argument passed to the macro appended to it.  
* `put()` function/task should also have an argument.  
  
When the macros are called, UVM will create two new classes by the name **uvm_put_imp_1** and **uvm_put_imp_2**. That is the reason why we have to append the argument to `uvm_put_imp` when trying to create an object. Even the `put()` method defined in those classes has the argument appended to it. we can give any names as the argument instead of **_1** and **_2**, but need to use the same afterward also.
 
![TLM1 drawio (2)](https://user-images.githubusercontent.com/113421192/200131828-ff8a5081-dbdb-429c-8683-f107fb8ae937.png)   

```
Fig.26 - Multiple incoming data producers for single receiver with multiple exports  
```

* **Example:**   

Let's first create Producer A and Producer B.  

         //Producer A  
   
        class prodA extends uvm_component;   
        `uvm_component_utils(prodA)  
   
        uvm_blocking_put_port #(packet) send;  
        packet pkt;
   
        function new(string name = "prodA", uvm_component parent = null);
         super.new(name, parent);
        endfunction
   
        virtual function void build_phase(uvm_phase phase);
         super.build_phase(phase);
        send=new("send",this);
        endfunction
 
        virtual task run_phase(uvm_phase phase);
        repeat(2) begin
         pkt=packet::type_id::create("pkt");
         assert(pkt.randomize());
         `uvm_info("prodA", "packet sent to consumer", UVM_LOW)
         pkt.print();
         send.put(pkt);
        end
        endtask
        
        endclass

        //Producer A  
   
        class prodB extends uvm_component;   
        `uvm_component_utils(prodB)  
   
        uvm_blocking_put_port #(packet) send;  
        packet pkt;
   
        function new(string name = "prodB", uvm_component parent = null);
         super.new(name, parent);
        endfunction
   
        virtual function void build_phase(uvm_phase phase);
         super.build_phase(phase);
        send=new("send",this);
        endfunction
 
        virtual task run_phase(uvm_phase phase);
        repeat(2) begin
         pkt=packet::type_id::create("pkt");
         assert(pkt.randomize());
         `uvm_info("prodB", "packet sent to consumer", UVM_LOW)
         pkt.print();
         send.put(pkt);
        end
        endtask
        
        endclass  

Now let's us create consumer  

         `uvm_blocking_put_imp_decl (_1)  //should be outside the class
         `uvm_blocking_put_imp_decl (_2)
 
         //Consumer
   
         class consumer extends uvm_component;
         `uvm_component_utils(consumer)
 
          uvm_blocking_put_imp_1 #(packet, consumer) put_imp1;
          uvm_blocking_put_imp_2 #(packet, consumer) put_imp2;
   
          function new(string name = "consumer", uvm_component parent = null);
           super.new(name, parent);
          endfunction
 
          virtual function void build_phase(uvm_phase phase);
           super.build_phase(phase);
          put_imp1=new("put_imp1", this);
          put_imp2=new("put_imp2", this);
          endfunction

          function void put_1(packet pkt);
           `uvm_info("CONS" , "packet received from put_1", UVM_LOW)
           pkt.print();
          endfunction
  
          function void put_2(packet pkt);
           `uvm_info("CONS" , "packet received from put_2", UVM_LOW)
           pkt.print();
         endfunction
 
         endclass

The environment will have all three component instantiations, and connect producer A with consumer **put_imp1** port, while producer B will be connected to consumer **put_imp2**.  

```
      //Environment
  
     class environment extends uvm_env;
     `uvm_component_utils(environment)
  
     prodA pA;
     prodB pB;
     consumer c;
    
     function new(string name = "environment", uvm_component parent = null);
      super.new(name, parent);
     endfunction
  
     virtual function void build_phase(uvm_phase phase);
      super.build_phase(phase);
      pA = prodA::type_id::create("pA",this);
      pB = prodB::type_id::create("pB",this);
      c = consumer::type_id::create("c", this);
    endfunction
  
     virtual function void connect_phase(uvm_phase phase);
      super.connect_phase(phase);
      pA.send.connect(c.put_imp1);
      pB.send.connect(c.put_imp2);
    endfunction
    endclass
```
```
Example.14 - Code for Tlm decl_macros     
```
  
* **Output:**  

![TLMNEW drawio](https://user-images.githubusercontent.com/106074838/200777110-91fd79dc-dd05-4963-8572-068d21ce960b.png)

![TLMNEW11 drawio](https://user-images.githubusercontent.com/106074838/200777200-fb5660ce-9055-4368-adaf-8087a9b9d26e.png)


```
Fig.27 - Output Screenshots for usage of TLM decl macros  
```

As we can see in the output that the producer B sent a packet to the consumer i.e., a='he, b='hd, and c='h0, and now the consumer received a packet from put_2 i.e., a='he, b='hd, and c='h0. Producer A sent a packet to the consumer i.e., a='h9, b='h0, and c='h0, and now the consumer received a packet from put_1 i.e., a='h9, b='h0, and c='h0.  
Here it will not override the values, it will store both producer A and B values in one consumer.  

**GitHub code link:** https://github.com/muneeb-mbytes/UVM_Course/blob/b7_Team_SiliconCrew/TLM/TLM_decl_macros/TLM_decl_macros.sv  

**GitHub log file link:**  https://github.com/muneeb-mbytes/UVM_Course/blob/b7_Team_SiliconCrew/TLM/TLM_decl_macros/TLM_decl_macros_log.log  




